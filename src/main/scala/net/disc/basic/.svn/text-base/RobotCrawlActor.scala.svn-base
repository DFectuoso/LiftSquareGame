package net.twitknow.game

import scala.actors._
import Actor._
import net.liftweb.util._
import net.liftweb.mapper._
import scala.collection.mutable.HashMap
import scala.xml._
import net.liftweb.http.ActorWatcher

import _root_.dispatch._
import oauth.Consumer
import twitter._
import oauth.Token
import json.Js._
import net.twitknow.game.model._
abstract class RobotCrawlActor extends Actor

class RobotCrawler(owner:Long,consumer:Consumer,token:Token, toCrawd:Int) extends RobotCrawlActor {
	var toCrawl = toCrawd
	if(toCrawl > 16){
		toCrawl = 16
	}
	var crawled = 0
  	ActorPing.schedule(this, Tick, net.liftweb.util.Helpers.TimeSpan(1L)) // schedule a ping every 10 seconds so we redraw

//  def render = bind("time" -> Text(timeNow.toString))
	def act = {
  		link(ActorWatcher)
  		loop {
    		react {
    			case Tick =>
					val available = ('remaining_hits ! num)(Http(Account.rate_limit_status(consumer,token)))
					println("RobotCrawlActor Pinging " + token + " le quedan " + available)
					
					val public_timeline = (Http(Status.friends_timeline(consumer,token,crawled)))
					crawled = crawled + 1
					public_timeline map { js =>
				  		val text = ('text ! str )(js)
				  		val id = ('id ! num)(js)
				  		val userElement = ('user ! obj)(js)
				  		val username = ('screen_name ! str)(userElement)
				  		val userImage = ('profile_image_url ! str)(userElement)
						Message.findOrCreate(id.intValue,text,username,userImage,owner)
					}

					
//					val public_timeline = (Http(Status.friends_timeline(consumer,token)))
//					println(public_timeline)
					if(available > 1 && toCrawl > crawled)
    					ActorPing.schedule(this, Tick, net.liftweb.util.Helpers.TimeSpan(10000L)) // schedule an update in 10 seconds
  				}
			}
		}
}

case object Tick 
